minisphere 1.1 API Documentation
================================

minisphere uses JavaScript for game logic. This is similar to the Sphere
engine, which minisphere is designed to be compatible with.  In fact,
the vast majority of the API is identical to Sphere's, with a handful of
backwards-compatible enhancements.

This file documents the functions exposed by minisphere for use in game
scripts. This list is not yet exhaustive; see the included Sphere 1.5 API
reference for the full list of legacy functions (a few may not be supported,
however).


Engine Identification
---------------------

The functions below can be used to determine, at a broad level, the
engine's level of support for various features.

GetVersion()

  Returns the Sphere API version level as a floating point number. When
  called in minisphere 1.1, this function returns 1.5, indicating API
  compatibility with Sphere 1.5.

GetVersionString()

    Returns the engine's version identification string. minisphere 1.1
    identifies as:
    
      v1.5 (compatible; minisphere 1.1)

GetExtensions()

  Returns an array of strings representing the engine's built-in
  capabilities. minisphere currently supports the following extensions (most of
  these should be self-explanatory):
  
    * minisphere
    * sphere-legacy-api
    * sphere-obj-constructors
    * sphere-obj-props
    * sphere-map-engine
    * sphere-galileo
    * minisphere-async-api
    * minisphere-galileo-shaders
    * minisphere-new-sockets
    * minisphere-rng-object
    * frameskip-api
    * set-script-function
    

Script Management
-----------------

Outside of very simple one-off games, most projects will consist of
multiple script files. You will need to know how to use the functions
below if you expect to get very far!

RequireScript(filename)
EvaluateScript(filename)

  Evaluates the contents of `filename`, as if the code contained within
  were part of the script containing the call. If you've ever worked in
  C or C++, this is a bit like including a header file. The filename is
  assumed to be relative to [game.sgm root]/scripts.
  
  Note: RequireScript only executes a given script once, regardless
  of how many RequireScript() calls specifying it are encountered. This
  is generally preferable to EvaluateScript(), which always executes the
  script.

RequireSystemScript(filename)
EvaluateSystemScript(filename)

  Same as above, except the filename is relative to
  [engine root]/system/scripts instead of the game directory. This
  allows you to use scripts included with the engine.


Basic Debugging
---------------

minisphere doesn't include a stepping debugger, so these may come in
handy!

Abort(message[, stack_offset])

  Forces the engine to close, displaying a specified error message. The
  error is normally said to originate at the location of the Abort()
  call; you may pass an optional negative stack offset to blame it on a
  function earlier in the call chain. For example, the following code
  will report an error at the point PassTheBuck() is called instead of
  at the Abort() call:
  
  function PassTheBuck()
  {
      Abort("PassTheBuck() says: It's not my fault!", -1);
  }
  PassTheBuck();

Alert(message[, stack_offset])

  Similar to Abort(), except the message is displayed in a dialog box
  and the game continues running as normal afterwards. Useful for
  examining variables at runtime when debugging.

Assert(condition, error_message[, stack_offset]);
  
  If `condition` evaluates to true, does nothing. Otherwise an error is thrown
  with the error text set to `error_message`. In the Console engine, the error
  is shown in a dialog box with the option to ignore it.


Logging
-------

Logging is another useful debugging tool. When trying to diagnose a stubborn
bug, it often helps to be able to see a detailed summary of everything that
happened when the issue surfaced. Of course, this requires some vigilance on the
part of the developer to add enough log entries!

new Logger(filename)

  Opens a file for logging and constructs an object you can use to access the
  log. `filename` is relative to <game dir>/logs. An error will be thrown if the
  file cannot be opened for writing.

Logger:write(text)
  
  Logs a line with the specified `text` at the current indent level.

Logger:beginBlock(name)
  
  Opens a block with the heading `name` and increases the indent level. Blocks
  can be nested and are useful to group related log entries.

Logger:endBlock()
  
  Closes the innermost block and decreases the indent level.


Execution Control and Game Management
-------------------------------------

Most of these are only useful for startup games, which can be
distributed with the engine and allow the user to choose a game to play.
For these functions to work, a `games` directory must be placed in the
same directory as the engine, alongside the `system` directory,
with subdirectories for each game.

GetGameInformation()
  
  Returns an object describing the currently running game. The object is of the
  same form as those returned by GetGameList() (see below).

GetGameList()

  Returns an array of objects, one for each Sphere game found in
  [engine root]/games. Each object has the following properties:
    
    .name:        The game's title, taken from game.sgm.
    .directory:   The directory the game was found in, relative to
                  [engine root]/games.
    .author:      The game's author, taken from game.sgm.
    .description: A short description of the game, taken from game.sgm.

ExecuteGame(directory)

  Replaces the currently running game with the one found in the
  specified directory. The directory is assumed to be relative to
  [engine root]/games.
  
RestartGame()

  Restarts the current game. All game state is cleared and the game()
  function is called again, as if the game was just started.

Exit()
  
  Exits the current game and shuts down the engine. If the current game
  was started by via ExecuteGame(), the original game will be restarted
  following the Exit() call.
  
Async(script);
  
  Queues a script or function to be executed on the next FlipScreen() call. This
  is similar to setTimeout(func, 0); in the browser.


Random Number Generation
------------------------

Many games have need of a good random number generator, particularly RPGs. All
JavaScript engines have a built-in generator in the form of the Math.random()
function, however this is generally considered subpar. minisphere provides the
RNG object, which uses the MT19937 (Mersenne Twister) algorithm to generate
random values and allows manual seeding.

RNG.seed(seed);

  Seeds the random number generator with `seed`. If the seed is floating point,
  it will be truncated to an integer; using a seed of 812.88, for example, has
  the same effect as 812.

RNG.chance(odds);

  Tests a percentage chance. Returns true if the chance succeeds, false
  otherwise. `odds` is a value between 0 and 1; for example, 0.75 will return
  true 75% of the time.

RNG.normal(mean, sigma);

  Returns a random floating point value normally distributed around `mean` with
  a standard deviation specified by `sigma`. The probability distribution of
  this function is sometimes termed a "bell curve."

RNG.random();

  Returns a floating point value in the range [0,1). This is the basic method of
  random number generation, and a direct, drop-in replacement for Math.random().

RNG.range(min, max);

  Returns a random integer uniformly distributed within the range [min,max].

RNG.sample(array);

  Returns a single randomly-chosen item from `array`.

RNG.vary(mean, variance);

  Returns a random floating point value uniformly distributed around `mean` with
  a maximum deviation specified by `variance`.


Graphics Routines
-----------------

minisphere, like Sphere, uses double-buffered rendering. In this scheme, all
drawing is done to a backbuffer, which is not visible to the user, and then
"flipped" once per frame, so that the player only sees the final rendering
output.

FlipScreen();

  Flips the backbuffer. Note that this also performs event loop processing, so
  if it is not called regularly, the engine will stop responding.

SetFrameRate(fps);
GetFrameRate();

Gets or sets the current target frame rate. Your game will be automatically
throttled to match this framerate. If `fps` is zero, the game will be
unthrottled, which may be useful for benchmarks but otherwise is usually a waste
of CPU resources.

GetScreenWidth();
GetScreenHeight();

  Gets the current screen resolution width and height.

SetClippingRectangle(x, y, width, height);
GetClippingRectangle();
  
  Gets or sets the clipping rectangle. All rendering done to the backbuffer is
  constrained to this rectangle. Note that GetClippingRectangle() returns the
  current clipping rectangle as an object describing it, with `x`, `y`, `width`
  and `height` properties.

ApplyColorMask(color);
  
  Applies a full-screen color mask. The color passed in is multiplied with the
  pixels of the backbuffer to tint the screen. This may be used for, e.g.
  day/night effects.


Galileo Graphics Primitives
---------------------------

Wondered what that `sphere-galileo` extension was above? This is it! It's a
more modern approach to graphics rendering based on precomposing scenes from
groups of shapes which can then be transformed and rendered as a unit.

All the old-school primitives provided by Sphere 1.5 are still available in
minisphere. However, there's a newer, much more modern way: the Shape and Group
objects.  With these, you precompose a complex object out of a set of vertices
and textures which are then uploaded to the GPU to save time during the main
render loop.

GetDefaultShaderProgram();
  
  Gets the default Galileo shader program. This is a very barebones shader which
  uses screen coordinates for vertices and performs only basic texture mapping
  in the fragment shader.

new ShaderProgram(shader_files);
  
  Constructs a ShaderProgram from a set of shader sources. `shader_files` should
  be an object with the following properties:
    
    vertex:   The filename of the source for the vertex shader.
    fragment: The filename of the source for the fragment shader.

  Note: Shader filenames are relative to <game_dir>/shaders.
  
new Vertex(x, y[, color[, u, v]]);
  
  Constructs an object describing a vertex of a shape. x and y specify the
  location of the vertex relative to the shape's origin. The color, if
  specified, is multiplied with the texture at that point in the shape to "tint"
  the vertex.  U/V are texture coordinates ranging from 0 to 1 describing the
  part of the texture which will be mapped to that vertex.

new Shape(vertices, image[, primitive_type]);

  Constructs a primitive shape out of the provided array of vertices textured
  with the Image object specified by `image`. `primitive_type` is optional and
  can be one of the following:
    
    SHAPE_AUTO - Primitive type is determined automatically based on the number
                 of vertices. This is the default.
    
    SHAPE_POINT_LIST - A point list. Each vertex represents a single point to be
                       rendered. Useful for particle effects.
  
    SHAPE_LINE_LIST - A line list. Each pair of vertices represents a line
                      segment.
    
    SHAPE_TRIANGLE_LIST - A triangle will be drawn for every 3 vertices.
    
    SHAPE_TRIANGLE_STRIP - A triangle strip. The first 3 vertices represent a
                           complete triangle, and each subsequent vertex is
                           combined with the previous two to form another.
                           Number of triangles drawn is equal to
                           (num_verts - 2).
    
    SHAPE_TRIANGLE_FAN - A series of triangles is drawn, all sharing the first
                         vertex. As with a strip, the number of triangles is
                         equal to (num_verts - 2).

Shape:image (read/write)
  
  The Image to be used when texturing the shape. This can be null, in which case
  the vertex colors alone will determine the rendered shape's appearance.

new Group(shapes, shader);
  
  Constructs a Group out of the provided array of Shape objects. `shader` is the
  shader program to use when rendering the group, obtained by calling either the
  ShaderProgram constructor or GetDefaultShaderProgram().

Group:draw();
  
  Renders the group to the backbuffer. Any transformations specified for the
  group (see below for properties) are applied as if the entire group were a
  single primitive.

Group:x (read/write)
Group:y (read/write)
  
  Sets the location the Group will be drawn at. When using default shaders,
  these are in raster coordinates where +X is right and +Y is down. Note that
  the translation described by these values is applied *after* rotation. To
  apply translation before rotation, use the `rotX` and `rotY` properties (see
  below).

Group:angle (read/write)
  
  The entire Group is rotated by this angle when rendered.

Group:rotX (read/write)
Group:rotY (read/write)
  
  Specifies the amount by which to translate before rotation is applied. The
  shapes in the group will revolve about the origin at a distance determined by
  these values.


Networking (Sockets)
--------------------

minisphere includes an advanced sockets API which is more flexible than the one
Sphere provides. The old routines are still available, but should be considered
deprecated. Under minisphere, sockets are divided into two types: Listening
sockets, used for servers, and I/O sockets, for clients.

GetLocalName();
  
  Returns the calling machine's network name.

GetLocalAddress();

  Returns the calling machine's local IP address.

new ListeningSocket(port[, backlog_size]);
  
  Constructs a new listening socket which listens for connections on `port`.
  `backlog_size` specifies the size of the backlog. If the backlog fills, new
  connections will be dropped.

ListeningSocket:accept();

  If one or more connections are waiting in the backlog, accepts one of them and
  returns an IOSocket object representing the connection. Otherwise, returns
  null. This should be called regularly to prevent the backlog from filling up.

ListeningSocket:close();
  
  Disconnects the socket. Any sockets in the backlog will be purged and no new
  connections can be made unless a new ListeningSocket is created.

new IOSocket(hostname, port);
  
  Connects to `hostname` on `port` and constructs an IOSocket representing the
  connection. The hostname can either be a named address (e.g. google.com) or an
  IP address (e.g. 127.0.0.1). As this operation is non-blocking, a valid socket
  will be returned even if the connection can be not be made; you must call
  IOSocket:isConnected() to find out when the connection has opened.

IOSocket:remoteAddress (read-only)
  
  Gets the IP address of the upstream end of the socket. Throws an error if
  accessed before a connection has been established.

IOSocket:remotePort (read-only)
  
  Gets the port that the remote machine is using for the connection. Generally
  not a useful statistic, but it's there if you need it. Throws an error if
  accessed before a connection is established.

IOSocket:isConnected();
  
  Returns true if the a connection has been established. As long as this returns
  false, you cannot call any other methods on the socket object. Doing so will
  cause an error to be thrown.

IOSocket:getPendingReadSize();
  
  Gets the amount of data, in bytes, currently in the receive buffer. Call
  IOSocket:read() or :readString() to retrieve this data.

IOSocket:read(bytes);
  
  Reads up to `bytes` bytes from the socket and returns a ByteArray containing
  the data received.

IOSocket:readString(bytes);
  
  Same as IOSocket:read(), but returns a string instead of a ByteArray. This may
  be more convenient, depending on your use case.

IOSocket:write(data);

  Writes data to the socket, which can be read at the other end. `data` can be
  either a ByteArray or a string.

IOSocket:close();

  Disconnects the socket. Note that a socket object cannot be reused after it
  has been closed; a new one must be created.
  

Map Engine
----------

minisphere's map engine is fully compatible with the one found in Sphere 1.5 and
very powerful.  It's also very easy to get up and running. This section is
incomplete; the APIs below are only the basics. See the included Sphere 1.5 API
documentation for the full set of map functions.

MapEngine(map_file, framerate);

  Starts the map engine, loading `map_file` as the initial map. `framerate`
  specifies the framerate the map engine will run at; a framerate of 0 will run
  unthrottled, which may be useful for benchmarks but is generally useless
  otherwise.
  
  `map_file` is assumed to be relative to the "maps" directory in the game.sgm
  root.

IsMapEngineRunning();
  
  Returns true if the map engine is currently running.

ChangeMap(map_file);

  Loads `map_file` into the map engine. This destroys any transient
  persons automatically. Transient persons are those defined in the map
  file as well as any created by passing `true` as the third argument
  to CreatePerson().

MapToScreenX(layer, x);
MapToScreenY(layer, y);
ScreenToMapX(layer, x);
ScreenToMapY(layer, y);

  Converts between map and screen coordinates.

SetUpdateScript(fn);
SetRenderScript(fn);
  
  Sets a function `fn` to be called once per map engine frame. Game state should
  be updated in the update script, while drawing is done in the render script.
  The distinction is important, as render calls can be skipped to minimize lag.
  Note: You shouldn't call these functions when using miniRT. The runtime uses
  them internally and changing them out will break things.

SetMapEngineFrameRate(fps);
GetMapEngineFrameRate();

  Gets or sets the map engine framerate. Set it to 0 to run the map engine
  unthrottled (not generally useful outside of benchmarks).

GetCurrentMap();
  
  Gets the filename of the current map, relative to <game_dir>/maps.

AttachInput(name);
DetachInput();
IsInputAttached();
GetInputPerson();
  
  Attaches, detaches or gets the input focus. The player will have control of
  the person with input focus. `name` is the name of the person as passed to
  CreatePerson().

AttachCamera(name);
DetachCamera();
IsCameraAttached();
GetCameraPerson();
  
  Attaches, detaches, or gets the camera focus. The camera will remain centered
  on whichever person it's attached to as they move about the map. `name` is the
  name of the person as passed to CreatePerson().

SetCameraX();
SetCameraY();
GetCameraX();
GetCameraY();

Gets or sets the camera position. Note: If the camera is placed beyond the edge
of a non-repeating map, the map's corresponding edge script will be called.

UpdateMapEngine();
  
  Updates the map engine per frame. Used to keep the map engine operating in
  the background when running a tight loop. Note that map input will not be
  accepted during an UpdateMapEngine() loop.

RenderMap();
  
  Renders the current map and set of persons to the backbuffer. Used
  along with UpdateMapEngine() to keep the map engine operating when
  running a tight loop.

ExitMapEngine();
  
  Tells the map engine to shut down at the start of the next frame. If
  the map engine is presently held up in an UpdateMapEngine() loop (see
  below), this call will not take effect until control returns to the
  map engine proper.


Persons Management
------------------

Persons are the Sphere term for what most RPG map engines call 'entities'.  They
are so named for their typical use case--representing persons on a map.
Typically you create one or more persistent persons to represent your player
characters, and the rest are transient, to be destroyed when a new map is
loaded.

CreatePerson(name, spriteset, transient);
  
  Creates a person using the spriteset specified by `spriteset`. This can either
  be an .rss spriteset path (relative to <game_dir>/spritesets) or a Spriteset
  object. If `transient` true, the person is transient and will automatically be
  destroyed when a new map is loaded via ChangeMap().

DestroyPerson(name);
  
  Destroys the person, removing it from play. This works on persons
  created manually via CreatePerson() as well as those created during
  map load, so be careful!

GetPersonList();
  
  Returns an array of person names representing all the persons that
  currently exist.

DoesPersonExist(name);
  
  Returns true if a person named `name` currently exists, otherwise
  returns false.

SetPersonX(name, new_x);
SetPersonY(name, new_y);
SetPersonLayer(name, layer);
GetPersonX(name);
GetPersonY(name);
GetPersonLayer(name);

  Gets or sets a person's position relative to the current map. `layer` can be
  either a 0-based layer index or a layer name. Note: For compatibility reasons,
  GetPersonLayer() always returns the index.

SetPersonXYFloat(name, new_x, new_y);
GetPersonXFloat(name);
GetPersonYFloat(name);

  Gets or sets a person's position relative to the current map, with
  subpixel precision.

SetPersonDirection(name, new_dir);
GetPersonDirection(name);

  Gets or sets a person's current "direction". The "direction" is actually the
  name of a pose as defined in the spriteset file. Note: A spriteset is required
  to have a pose for at least each of the 4 cardinal directions (north, east,
  south and west).

FollowPerson(name, leader_name, distance);

  Makes a person follow another person at a distance specified by
  `distance`. Note that the distance is not absolute and the actual
  trailing distance depends on the leader's speed. Faster leaders will
  put more distance between themselves and their followers.
  
  To detach a follower and make them independent again, call the
  function again like this:
    
    FollowPerson("<name>", null, 0);

GetPersonLeader(name);
  
  Gets the person `name` is currently following. If no leader exists
  (the person is independent), returns an empty string ("").

GetPersonFollowers(name);

  Gets an array of names of persons following a specified person.

GetPersonFollowDistance(name);
SetPersonFollowDistance(name);
  
  Gets or sets the named person's follow distance. Throws an error if
  the person is not following anyone.

IsPersonVisible()
SetPersonVisible(is_visible)

  Gets or sets the person's visibility status. 'true' if visible, 'false' if
  not.

IsPersonObstructed(name, x, y);
  
  Checks whether the person would be obstructed at a given location. Useful for
  pathfinding.

GetObstructingPerson(name, x, y);
  
  If the person named `name` is obstructed by a person at the given location,
  returns the offending person's name. Otherwise, returns an empty string ("").

GetObstructingTile(name, x, y);
  
  If the person named `name` is obstructed by a map tile at the given location,
  returns the tile index. Otherwise, returns -1.

SetPersonSpeed(name, speed);
SetPersonSpeedXY(name, new_speed_x, new_speed_y);
GetPersonSpeedX(name);
GetPersonSpeedY(name);

  Gets or sets the person's speed in two dimensions. SetPersonSpeed(name, speed)
  is shorthand for SetPersonSpeedXY(name, speed, speed).

SetPersonSpriteset(name, spriteset);
GetPersonSpriteset(name);

  Gets the person's current spriteset as a Spriteset object.

IsIgnoringPersonObstructions(name);
IgnorePersonObstructions(name, ignore);

  Gets or sets whether the person is ignoring other persons. Ignored persons
  do not affect collision and cannot be talked to. Note that ignoring is mutual
  between persons.

IsIgnoringTileObstructions(name);
IgnoreTileObstructions(name, ignore);

  Gets or sets whether the person is ignoring tile obstructions. As with ignored
  persons, this disables tile collision.

QueuePersonCommand(name, command[, is_immediate]);

  Adds a command to the person's command queue. If `is_immediate` is true, the
  engine will immediately execute the next command in the queue. Otherwise,
  execution will halt until the next frame. The default is false. The following
  commands are supported:
    
    COMMAND_WAIT - do nothing, useful as a non-immediate command to delay for 
                   a frame.
    
    COMMAND_ANIMATE - advances the person's animation state by one frame. Queue
                      these continuously to animate the sprite.
    
    COMMAND_FACE_NORTH
    COMMAND_FACE_NORTHEAST
    COMMAND_FACE_EAST
    COMMAND_FACE_SOUTHEAST
    COMMAND_FACE_SOUTH
    COMMAND_FACE_SOUTHWEST
    COMMAND_FACE_WEST
    COMMAND_FACE_NORTHWEST
      
      Changes the person's facing direction. If the specified direction isn't
      available in the person's spriteset, the engine will use the closest
      match.
    
    COMMAND_MOVE_NORTH
    COMMAND_MOVE_NORTHEAST
    COMMAND_MOVE_EAST
    COMMAND_MOVE_SOUTHEAST
    COMMAND_MOVE_SOUTH
    COMMAND_MOVE_SOUTHWEST
    COMMAND_MOVE_WEST
    COMMAND_MOVE_NORTHWEST
      
      Moves the person a number of pixels determined by their speed. See
      SetPersonSpeed() above.

QueuePersonScript(name, script[, is_immediate]);
  
  Adds a script to the person's command queue. `is_immediate` has the same
  meaning and semantics as in QueuePersonCommand() above. `script` can be either
  a JavaScript source string or a function.

IsCommandQueueEmpty(name);
  
  Returns true if the person's command queue is empty, false otherwise.

ClearCommandQueue(name);
  
  Removes all commands and scripts from the person's command queue.
