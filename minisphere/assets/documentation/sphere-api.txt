minisphere 1.1 API Documentation
================================

minisphere uses JavaScript for game logic. This is similar to the Sphere
engine, which minisphere is designed to be compatible with.  In fact,
the vast majority of the API is identical to Sphere's, with a handful of
backwards-compatible enhancements.

This file documents the functions exposed by minisphere for use in game
scripts.


Engine Identification
---------------------

The functions below can be used to determine, at a broad level, the
engine's level of support for various features.

GetVersion()

  Returns the Sphere API version level as a floating point number. When
  called in minisphere 1.1, this function returns `1.5`, indicating API
  compatibility with Sphere 1.5.

GetVersionString()

  Returns the engine's version identification string. minisphere 1.1
  identifies as:
    o 32-bit engine: `v1.5 (compatible; minisphere 1.1)`
    o 64-bit engine: `v1.5 (compatible; minisphere 1.1 x64)`

GetExtensions()

  Returns an array of strings representing the engine's built-in
  capabilities. minisphere currently supports the following extensions:
  
    * `sphere-legacy-api`
      Sphere 1.x API support
    
    * `minisphere`
      minisphere-specific API extensions
      
    * `sphere-obj-constructors`
      Sphere objects can be created via `new`, e.g.
      var sound = new Sound("munch.wav");
      
    * `sphere-obj-props`
      Sphere objects include virtual properties, e.g.:
      sound_obj.volume = 0.5;
      
    * `sphere-new-sockets`
      Support for IOSocket and ListeningSocket objects
    
    * `frameskip-api`
      API functions for managing frame skipping
      
    * `set-script-function`
      Engine allows passing JavaScript functions to SetxxxScript(), e.g.
      SetUpdateScript(function() { Threads.updateAll(); });
    

Basic Debugging
---------------

minisphere doesn't include a stepping debugger, so these may come in
handy!

Abort(message[, stack_offset])

  Forces the engine to close, displaying a specified error message. The
  error is normally said to originate at the location of the Abort()
  call; you may pass an optional negative stack offset to blame it on a
  function earlier in the call chain. For example, the following code
  will report an error at the point PassTheBuck() is called instead of
  at the Abort() call:
  
  function PassTheBuck()
  {
      Abort("PassTheBuck() says: It's not my fault!", -1);
  }
  PassTheBuck();

Alert(message[, stack_offset])

  Similar to Abort(), except the message is displayed in a dialog box
  and the game continues running as normal afterwards. Useful for
  examining variables at runtime when debugging.


Script Management
-----------------

Outside of very simple one-off games, most projects will consist of
multiple script files. You will need to know how to use the functions
below if you expect to get very far!

RequireScript(filename)
EvaluateScript(filename)

  Evaluates the contents of `filename`, as if the code contained within
  were part of the script containing the call. If you've ever worked in
  C or C++, this is a bit like including a header file. The filename is
  assumed to be relative to [game.sgm root]/scripts.
  
  Note: RequireScript only executes a given script once, regardless
  of how many RequireScript() calls specifying it are encountered. This
  is generally preferable to EvaluateScript(), which always executes the
  script.

RequireSystemScript(filename)
EvaluateSystemScript(filename)

  Same as above, except the filename is relative to
  [engine root]/system/scripts instead of the game directory. This
  allows you to use scripts included with the engine.


Execution Control and Game Management
-------------------------------------

Most of these are only useful for startup games, which can be
distributed with the engine and allow the user to choose a game to play.
For these functions to work, a `games` directory must be placed in the
same directory as the engine, alongside the `system` directory,
with subdirectories for each game.

GetGameList()

  Returns an array of objects, each representing a game directory found
  in [engine root]/games. Each object has the following properties:
    
    .name:        The game's title, taken from game.sgm.
    .directory:   The directory the game was found in, relative to
                  [engine root]/games.
    .author:      The game's author, taken from game.sgm.
    .description: A short description of the game, taken from game.sgm.

ExecuteGame(directory)

  Replaces the currently running game with the one found in the
  specified directory. The directory is assumed to be relative to
  [engine root]/games.
  
RestartGame()

  Restarts the current game. All game state is cleared the the game()
  function is called again, as if the game was just started.

Exit()
  
  Exits the current game and shuts down the engine. If the current game
  was started by via ExecuteGame(), the original game will be restarted
  following the Exit() call.


Map Engine
----------

minisphere's map engine is fully compatible with the one found in
Sphere 1.5 and very powerful.  It's also very easy to get up and
running.

MapEngine(map_file, framerate);

  Starts the map engine, loading `map_file` as the initial map.
  `framerate` specifies the framerate the map engine will run at; a
  framerate of 0 will run unthrottled, which may be useful for
  benchmarks but is generally useless otherwise.
  
  `map_file` is assumed to be relative to the "maps" directory in the
  game.sgm root.

ExitMapEngine()
  
  Tells the map engine to shut down at the start of the next frame.

ChangeMap(map_file)

  Loads `map_file` into the map engine. This destroys any transient
  persons automatically. Transient persons are those defined in the map
  file as well as any created by passing `true` as the third argument
  to CreatePerson().

AttachCamera(person)
  
  Attaches the camera to `person`. The camera will remain centered on
  whichever person it's attached to as they move about the map.

AttachInput(person)
  
  Grants the player control of `person`.

UpdateMapEngine()
  
  Updates the map engine the next frame. Used to keep the map engine
  operating when running a tight loop.

RenderMap()
  
  Renders the current map and set of persons to the backbuffer. Used
  along with UpdateMapEngine() to keep the map engine operating when
  running a tight loop.


Persons Management
------------------

Persons are the Sphere term for what most RPG map engines call
'entities'.  They are so named for their typical use case--representing
persons on a map. Typically you create one or more persistent persons
to represent your player characters, and the rest are transient, to be
destroyed when a new map is loaded.

CreatePerson(name, spriteset_file, destroy_with_map)
  
  Creates a person using the spriteset stored in `spriteset_file`.
  If `destroy_with_map` is true, the person is transient and will be
  automatically destroyed (deleted) when a new map is loaded via
  ChangeMap().

DestroyPerson(name)
  
  Destroys the person, removing it from play. This works on persons
  created manually via CreatePerson() as well as those created during
  map load, so be careful!

GetPersonList()
  
  Returns an array of person names representing all the persons that
  currently exist.

DoesPersonExist(name)
  
  Returns true if a person named `name` currently exists, otherwise
  returns false.

FollowPerson(name, leader_name, distance)
  
  Makes a person follow another person at a distance specified by
  `distance`. Note that the distance is not absolute and the actual
  trailing distance depends on the leader's speed. Faster leaders will
  put more distance between themselves and their followers.
  
  To detach a follower and make them independent again, call the
  function again like this:
    
    FollowPerson("<name>", null, 0);
